---
page_id: 5c66163f-2dc9-485c-875c-a3c5f5653003
---

# Sanitization: Benutzereingaben reinigen
Schauen Sie sich folgendes Beispielprogramm an:

```python showLineNumbers
entscheidung = input('MÃ¶chten Sie Ihre Ã„nderungen speichern? (ja/nein) ')

if entscheidung == 'ja':
    print('âœ… Ã„nderungen gespeichert')
else:
    print('ğŸš® Alle Ã„nderungen wurden verworfen')
```

Das Programm funktioniert zwar, doch es gibt ein Problem in der Anwendung:

```
MÃ¶chten Sie Ihre Ã„nderungen speichern? (ja/nein) Ja
ğŸš® Alle Ã„nderungen wurden verworfen
```

oder

```
MÃ¶chten Sie Ihre Ã„nderungen speichern? (ja/nein)     ja
ğŸš® Alle Ã„nderungen wurden verworfen
```

:::insight[Was ist hier passiert?]
Der Wert der Variable `entscheidung` entspricht in diesen FÃ¤llen nicht genau dem String `'ja'`. Somit ist die Bedingung auf Zeile `3` `False` und wir fÃ¼hren den `else`-Fall auf Zeile `6` aus.
:::

Um dieses Problem zu umgehen und unser Programm benutzerfreundlicher zu machen, gibt es zwei Arten, auf die wir solche Benutzereingaben meistens zuerst anpassen, bevor wir sie mit einem erwarteten Wert vergleichen:
1. **Die Eingabe wird zu Kleinbuchstaben verwandelt.** Wenn wir in den Vergleichswerten (hier Zeile `3`) ebenfalls nur Kleinbuchstaben verwenden, erreichen wir so den Effekt, dass die Gross- und Kleinschreibung in der Benutzereingabe Â«ignoriertÂ» wird.
2. **Die Eingabe wird _getrimmt_**. Alle Leerzeichen am Anfang und am Ende des Strings werden entfernt.

Diesen Prozess des _Standardisierens_ von Benutzereingaben nennt man **Sanitization** (engl.: _to sanitize_, reinigen, desinfizieren).

## String zu Kleinbuchstaben verwandeln
Dazu rufen wir auf einem beliebigen String die Funktion[^1] `.lower()` auf. Der RÃ¼ckgabewert[^2] ist ein identischer String mit nur Kleinbuchstaben:

```python showLineNumbers
wert = 'HaLLo'
wert = wert.lower()
print(wert)
```

produziert in der Kommandozeile die Ausgabe

```
hallo
```

## Leerzeichen am Anfang und am Ende entfernen
Dazu rufen wir auf einem beliebigen String die Funktion[^1] `.strip()` auf. Der RÃ¼ckgabewert[^2] ist ein identischer String ohne Leerzeichen am Anfang und am Ende:

```python showLineNumbers
wert = '       hallo   '
wert = wert.strip()
print(wert)
```

produziert in der Kommandozeile die Ausgabe

```
hallo
```

## Das verbesserte Beispielprogramm
Mit diesen beiden VerÃ¤nderungen kÃ¶nnen wir unser Beispielprogramm nun benutzerfreundlicher machen:
```python showLineNumbers
entscheidung = input('MÃ¶chten Sie Ihre Ã„nderungen speichern? (ja/nein) ')
entscheidung = entscheidung.lower()
entscheidung = entscheidung.strip()

if entscheidung == 'ja':
    print('âœ… Ã„nderungen gespeichert')
else:
    print('ğŸš® Alle Ã„nderungen wurden verworfen')
```

Wichtig ist dabei nur, dass der Vergleichswert (der String `ja` auf Zeile `5`) selbst ebenfalls nur Kleinbuchstaben und keine Leerzeichen am Anfang und am Ende hat.

```
MÃ¶chten Sie Ihre Ã„nderungen speichern? (ja/nein)     Ja
âœ… Ã„nderungen gespeichert
```

## Ãœbung
:::aufgabe[Benutzereingaben reinigen]
<TaskState id="0ac5db6a-b00e-4efa-97da-8cf425f2027a" />

Verbessern Sie das folgende Programm so, dass die Gross- und Kleinschreibung sowie Ã¼berflÃ¼ssige Leerzeichen am Anfang und am Ende der Benutzereingabe Â«ignoriertÂ» werden.

```py live_py id=40d8e0b1-7014-468c-97c4-9d1f0582a69f
entscheidung = input('Wie mÃ¶chten Sie weitermachen? (Bestellen / Hilfe / Abbrechen)')

if entscheidung == 'Bestellen':
    print('âœ… Bestellung aufgenommen')
elif entscheidung == 'Hilfe':
    print('ğŸ†˜ Hilfe wird angezeigt')
else:
    print('âŒ Ihr Warenkorb wurde geleert')
```
:::

## GÃ¼ltige Eingabe erzwingen
In manchen FÃ¤llen kÃ¶nnen wir nicht weitermachen, bis wir von der Benutzer:in eine gÃ¼ltige Eingabe erhalten haben. Beispielsweise hÃ¤tten wir hier ein Problem:

```py live_py readonly slim
entscheidung = input('Welche GrÃ¶sse mÃ¶chten Sie? (S / M / L)?')
if entscheidung == 'S':
    print('âœ… GrÃ¶sse S in den Warenkorb gelegt')
elif entscheidung == 'M':
    print('âœ… GrÃ¶sse M in den Warenkorb gelegt')
elif entscheidung == 'L':
    print('âœ… GrÃ¶sse L in den Warenkorb gelegt')
else:
    print('âŒ UngÃ¼ltige GrÃ¶sse. Bitte erneut versuchen.')

print('Vielen Dank fÃ¼r Ihre Bestellung!')
```

Dieses Programm ist unsinnig, denn wenn die Benutzer:in eine ungÃ¼ltige GrÃ¶sse eingibt, geben wir zwar eine Fehlermeldung aus â€“ die Bestellung wird aber trotzdem abgeschlossen.

Um dieses Problem zu lÃ¶sen, kÃ¶nnen wir die Eingabe in eine Funktion packen, die sich immer dann selbst nochmal aufruft, wenn die Eingabe ungÃ¼ltig war:

```py live_py readonly slim
def groesse_waehlen():
    entscheidung = input('Welche GrÃ¶sse mÃ¶chten Sie? (S / M / L)?')
    if entscheidung == 'S':
        print('âœ… GrÃ¶sse S in den Warenkorb gelegt')
    elif entscheidung == 'M':
        print('âœ… GrÃ¶sse M in den Warenkorb gelegt')
    elif entscheidung == 'L':
        print('âœ… GrÃ¶sse L in den Warenkorb gelegt')
    else:
        print('âŒ UngÃ¼ltige GrÃ¶sse. Bitte erneut versuchen.')
        groesse_waehlen()  # Die Funktion ruft sich selbst erneut auf, wenn die Eingabe ungÃ¼ltig war.

groesse_waehlen()
print('Vielen Dank fÃ¼r Ihre Bestellung!')
```

Aus dieser `groesse_waehlen()`-Â«SchleifeÂ»[^3] kommen wir also erst dann wieder heraus, wenn eine gÃ¼ltige GrÃ¶sse eingegeben wurde.

[^1]: Genaugenommen sprechen wir hier von einer Methode; siehe [OOP](OOP).
[^2]: siehe [RÃ¼ckgabewerte](Return).
[^3]: Es handelt sich hier nicht um eine Â«echteÂ» Schleife (`for` oder `while`). Wenn sich eine Funktion selbst aufruft, spricht man von **Rekursion**.