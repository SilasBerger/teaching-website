---
page_id: 1b0b7738-3bbb-49a8-b6ae-a10e840be031
sidebar_custom_props:
    source:
        ref: https://craft.rothe.io/RVDP1VFzxV372O/b/420198DB-E54E-4823-9DBB-A28111EC61A8/5.2-%E2%80%94-Huffman-Codierung
        name: rothe.io
---

export const styles = {
    startNode: {
        display: 'inline-block',
        backgroundColor: '#d9cfed',
        borderColor: '#d9cfed',
        borderRadius: '1em',
        padding: '0 0.5em'
    },
    intermediateNode: {
        display: 'inline-block',
        backgroundColor: '#ffefcc',
        borderColor: '#ffefcc',
        borderRadius: '1em',
        padding: '0 0.5em'
    },
    leafNode: {
        display: 'inline-block',
        backgroundColor: '#d5ebd4',
        borderColor: '#d5ebd4',
        borderRadius: '1em',
        padding: '0 0.5em'
    },
    newNode: {
        display: 'inline-block',
        backgroundColor: '#fed2cf',
        borderColor: '#f64c3e',
        borderRadius: '1em',
        padding: '0 0.5em'
    }
};

# Huffman-Codierung

David Huffman hat 1952 ein Verfahren entwickelt, mit welchem Zeichen platzsparender codiert werden kÃ¶nnen. Seine Idee ist, dass Zeichen, welche hÃ¤ufig im Text vorkommen, einen kÃ¼rzeren Code erhalten, als Zeichen, welche selten im Text vorkommen. Damit unterscheidet sich das Verfahren z.B. von der ASCII-Codierung, bei der alle Zeichen gleich viel Speicherplatz brauchen.

:::insight[Alltagsbezug] Die Huffman-Codierung und Ã¤hnliche Verfahren werden fÃ¼r das Komprimieren von Dateiformaten wie DOCX, JPG oder MP3 eingesetzt.[^1] :::

## BinÃ¤rbaum

Ein BinÃ¤rbaum ist eine Struktur mit **genau einem** <span style={styles.startNode}>Startknoten</span>, **mindestens einem** <span style={styles.leafNode}>Blattknoten</span> und **beliebig vielen** <span style={styles.intermediateNode}>Zwischenknoten</span>.

![--width=250px](img/Huffman_Annas_Ananas.png)

Hier handelt es sich um einen ganz bestimmten BinÃ¤rbaum: nÃ¤mlich um einen **Huffman-BinÃ¤rbaum**.

Um eine binÃ¤re Ziffernfolge mit diesem Baum zu decodieren, startet man beim <span style={styles.startNode}>Startknoten</span>. Von diesem aus geht es entweder nach links oder rechts unten weiter: Steht in der binÃ¤ren Ziffernfolge eine $0$, geht man nach links, bei einer $1$ geht man nach rechts. Wenn man einen <span style={styles.leafNode}>Blattknoten</span> (also einen Knoten mit einem Buchstaben) erreicht hat, hat man ein Zeichen decodiert und startet fÃ¼r das nÃ¤chste Zeichen wieder beim <span style={styles.startNode}>Startknoten</span>.

Nehmen wir als Beispiel die folgenden Daten:

```
0111101011000110110101
```

Die erste $0$ fÃ¼hrt uns vom Startknoten direkt zum Buchstaben `A`.

```
0|111101011000110110101 â†’ A
```

Anschliessend folgt eine $1$. Wir starten wieder beim Startknoten und kommen zum oberen Zwischeknoten. Es folgt nochmal eine $1$, womit wir beim Buchstaben `N` landen.

```
011|1101011000110110101 â†’ AN
```

:::aufgabe[Beispiel fertigstellen]

<TaskState id="8c074f14-73d1-47fc-b553-13f5fea602dd" />
Fahren Sie nach demselben Prinzip weiter, bis Sie die gesamte binÃ¤re Zeichenfolge abgearbeitet und so den Text
decodiert haben.

Geben Sie den decodierten Text hier ein (alles in Grossbuchstaben) und Ã¼berprÃ¼fen Sie Ihre Antwort.

<String id="4be3bb55-b5a4-4ca9-92c1-c29ca14d1199" solution="ANNAS ANANAS" />
:::

## Erstellen eines Huffman-Baums

Der obige Huffman-BinÃ¤rbaum ist natÃ¼rlich nicht allgemeingÃ¼ltig. FÃ¼r jeden Text, den wir komprimieren wollen, erstellen wir einen **individuellen Huffman-Baum**. Die damit codierten Daten lassen sich demnach auch **nur mit genau diesem Baum wieder decodieren**.

Wie der Huffman-Algorithmus funktioniert, soll am Beispiel der Codierung des Texts `EINTRITT FREI` gezeigt werden.

Zuerst zÃ¤hlt man, wie oft jedes Zeichen im Text vorkommt und erstellt eine HÃ¤ufigkeitstabelle.

| Zeichen | HÃ¤ufigkeit |
| ------- | ---------- |
| E       | 2          |
| I       | 3          |
| N       | 1          |
| T       | 3          |
| R       | 2          |
| â£       | 1          |
| F       | 1          |

Nun geht es darum, einen BinÃ¤rbaum zu erstellen. Dazu wird zunÃ¤chst fÃ¼r jeden Buchstaben ein Knoten gebildet. Die HÃ¤ufigkeit steht im Knoten, der Buchstaben darunter:

![](img/huffman_eintritt_frei_1.png)

Nun werden die **zwei Knoten mit den kleinsten HÃ¤ufigkeiten** an einen <span style={styles.newNode}>neuen Knoten</span> angehÃ¤ngt. Der neue Knoten enthÃ¤lt die **Summe der HÃ¤ufigkeiten** der ursprÃ¼nglichen Knoten:

![](img/huffman_eintritt_frei_2.png)

Dies wird wiederholt, bis alle Knoten miteinander verbunden sind. **Wenn zwei Knoten die gleiche HÃ¤ufigkeit haben, spielt es keine Rolle, welcher gewÃ¤hlt wird.** Im nÃ¤chsten Schritt wird der kleinste Knoten `N` mit `R` zusammengefasst. Es kÃ¶nnten aber auch `N` und `E` oder `N` und der neu erstellte Knoten zusammengefasst werden. Die LÃ¶sung ist somit **nicht eindeutig**: Es gibt mehrere korrekte LÃ¶sungen!

![](img/huffman_eintritt_frei_3.png)

Wichtig ist, dass **immer die kleinsten Knoten zusammengefasst** werden. Hier werden die zwei Knoten mit HÃ¤ufigkeit $2$ zusammengefasst:

![](img/huffman_eintritt_frei_4.png)

![](img/huffman_eintritt_frei_5.png)

![](img/huffman_eintritt_frei_6.png)

![](img/huffman_eintritt_frei_7.png)

Wenn der Baum fertig ist, werden alle Ã„ste, welche nach links zeigen, mit einer $0$ markiert. Alle die nach rechts zeigen, werden mit einer $1$ markiert.

![](img/huffman_eintritt_frei_8.png)

Nun kann eine **Codierungstabelle** erstellt werden, indem der Code fÃ¼r jedes Zeichen vom Baum abgelesen wird:

| Zeichen | Code |
| ------- | ---- |
| I       | 00   |
| T       | 01   |
| N       | 100  |
| R       | 101  |
| E       | 111  |
| âµ       | 1100 |
| F       | 1101 |

Mit dieser Codierungstabelle kÃ¶nnen wir nun â€“ genau wie z.B. mit der ASCII-Tabelle â€“ den Text binÃ¤r codieren.

Das Resultat: `EINTRITT FREI` â†’ `11100100011010001011100110110111100`.

:::key[Elemente einer Huffman-Codierung] Eine abgeschlossene Huffman-Codierung besteht also aus folgenden Elementen:

- HÃ¤ufigkeitstabelle
- Huffman-Baum
- Codierungstabelle
- Huffman-codierter Text (BinÃ¤rdaten) :::

:::aufgabe[KompressionsverhÃ¤ltnis]

<TaskState id="9c73836c-4f0c-4251-9ca4-d13368da86a7" />

Wie effizient wurde hier komprimiert?

ZÃ¤hlen Sie zuerst die Anzahl Bits in den Huffman-codierten BinÃ¤rdaten. Ãœberlegen Sie anschliessend, wie viele Bits wir fÃ¼r den Text `EINTRITTÂ FREI` benÃ¶tigen, wenn wir ihn ganz normal mit 8-Bit ASCII codieren.

Rechnen Sie anschliessend

$$ C = 100 \cdot (1 - \frac{\text{Anz. Bits mit Huffman}}{\text{Anz. Bits mit ASCII}})$$

um das KompressionsverhÃ¤ltnis $C$ dieser Huffman-Codierung in $\%$ des ASCII-codierten Vergleichswerts zu erhalten.

Geben Sie das Resultat hier ein (inkl. $\%$-Zeichen, gerundet auf eine Ganzzahl):

<String label="KompressionsverhÃ¤ltnis" id="b60fc310-2524-4420-85f1-e8105820d6f8" solution="66%" />

So viel $\%$ an Speicherplatz sparen wir also ein, wenn wir den Text mit Huffman statt mit 8-Bit ASCII codieren. :::

## Ãœbungen

:::aufgabe[Texte codieren]

<TaskState id="7af279ca-7df1-4b26-8e2e-6ed59642d4db" />
Gegeben sind folgende Texte: 1. `MISSISSIPPI` 2. `EXTERNER EFFEKT`

Gehen Sie fÃ¼r beide Texte **einzeln** je so vor:

1. Erstellen Sie eine HaÌˆufigkeitstabelle.
2. Erstellen Sie den Huffman-Baum.
3. Erstellen Sie daraus die Codierungstabelle.
4. Codieren Sie den Text mit der Codierungstabelle.

Bearbeiten Sie die beiden Texte als zwei separate Teilaufgaben. Arbeiten Sie auf Papier. Vergleichen Sie Ihre Resultate am Schluss mit der MusterlÃ¶sung.

<Solution id="c2d542fe-1257-4aad-9d23-2b81c0300472">
    **Achtung:** Der Huffman-Algorithmus produziert kein eindeutiges Ergebnis! Es kann also mehrere korrekte
    Huffman-BÃ¤ume, und somit auch mehrere korrekte Codierungstabellen und BinÃ¤rdaten geben. Falls Sie unsicher
    sind, lassen Sie Ihre LÃ¶sung gerne von der Lehrperson prÃ¼fen.
    <br />
    ![](img/loesung_huffman_mississippi.png) ![](img/loesung_huffman_externer_effekt.png)
</Solution>
:::

:::aufgabe[Verlustfrei oder verlustbehaftet?]

<TaskState id="48123a14-877f-42f8-b18d-294e6febf549" />
Handelt es sich bei Huffman um eine verlust**freie** oder eine verlust**behaftete** Kompression? BegrÃ¼nden
Sie.

<QuillV2 id="5e2b4edd-31b9-488e-9502-b0b124b41654" />

<Solution id="904ef7ec-ef8f-457d-b1be-d345a481a853">
    Es handelt sich um eine verlust**freie** Kompression. Mithilfe der Codierungstabelle kÃ¶nnen wir aus den
    Huffman-codierten BinÃ¤rdaten den ursprÃ¼nglichen Text vollstÃ¤ndig wiederherstellen.
    <br />
    Text eignet sich allgemein eher nicht fÃ¼r verlust**behaftete** Kompression. Wenn bei einem Bild die
    QualitÃ¤t etwas reduziert wird, ist das nicht so schlimm. Wenn bei einem Text aber einzelne Zeichen
    weggelassen werden, ist das meistens problematisch. Der Text bleibt zwar noch relativ lange lesbar (vor
    allem dann, wenn wir eher die hÃ¤ufigeren Buchstaben entfernen), aber als Leser:innen tolerieren wir dies
    kaum. Eine Ausnahme sind vielleicht AbkÃ¼rzungen und KurzwÃ¶rter (Â«z.B.Â», Â«ehem.Â», Â«GBSLÂ», Â«AzubiÂ»).
</Solution>
:::

:::aufgabe[â­ï¸ Exkurs: Bezug zu UTF-8]

<TaskState id="7cf810a9-a240-49d6-836b-42ec2f97857b" />
Â«Im Gegensatz zu ASCII ist UTF-8 ebenfalls eine Form der Kompression, weil dabei nicht jedes Zeichen gleich
viele Bytes braucht.Â»

Diskutieren Sie diese These. Stimmen Sie Ihr zu? Wieso (nicht)?

<QuillV2 id="f33b9e3a-2270-45c2-97e1-643177fb5d19" />

<Solution id="0383acf0-54fd-40f7-b754-51908a0b1cad">
    UTF-8 ist ein platzsparendes Codierungsverfahren fÃ¼r die Zeichen der Unicode-Tabelle. Die weit
    verbreiteten ASCII-kompatiblen Zeichen brauchen dabei nur je 1 Byte, wÃ¤hrend andere Zeichen wie etwa
    Emojis mit mehreren Bytes pro Zeichen codiert werden.
    <br />
    Hier von einer Kompression zu sprechen, scheint aber dennoch problematisch. UTF-8 orientiert sich
    schliesslich nicht primÃ¤r an der HÃ¤ufigkeit eines Zeichens. Je weiter hinten ein Zeichen auf der
    Unicode-Tabelle steht (sprich, je hÃ¶her seine Codepoint-Zahl), desto mehr Bytes benÃ¶tigt dessen
    Unicode-Codierung.
    <br />
    Die Unicode-Tabelle wird laufend ergÃ¤nzt, darf daneben aber niemals verÃ¤ndert (z.B. neu sortiert) werden,
    weil bestehende Texte sonst plÃ¶tzlich falsch decodiert wÃ¼rden. Es kÃ¶nnte nun sein, dass ein neu
    eingefÃ¼hrtes Zeichen plÃ¶tzlich an Beliebtheit gewinnt und deshalb sehr oft verwendet wird. Das Ã¤ndert aber
    nichts daran, dass es weit hinten in der Tabelle steht (Codepoint $> 150'000$) und seine UTF-8 Codierung
    somit mehrere Bytes ($\ge 4$) benÃ¶tigt.
    <br />
    Was wÃ¤re zudem mit einem Text wie `ğŸ‘‹â°ğŸ¦„ğŸ«`? UTF-8 kann nichts dagegen tun, dass sÃ¤mtliche dieser Zeichen
    mit je 4 Bytes codiert werden und der gesamte Text somit 16 Bytes benÃ¶tigt. Huffman kÃ¶nnte hier hingegen
    auf 2 Bits (!) pro Zeichen und somit 1 Byte fÃ¼r den gesamten Text komprimieren.
</Solution>
:::

[^1]: Wikipedia: [Huffman coding](https://en.wikipedia.org/wiki/Huffman_coding#Applications).
