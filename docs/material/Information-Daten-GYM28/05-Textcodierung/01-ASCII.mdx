---
page_id: cfea7de7-7a7a-429d-9438-7e11ef179930
sidebar_custom_props:
    source:
        ref: https://craft.rothe.io/RVDP1VFzxV372O/b/420200CB-8002-4E2F-AA92-2463350E077B/3.3-%E2%80%94-ASCII
        name: rothe.io
---

import String from "@tdev-components/documents/String";
import Solution from "@tdev-components/documents/Solution";
import TaskState from "@tdev-components/documents/TaskState";
import QuillV2 from "@tdev-components/documents/QuillV2";

# ASCII
Der American Standard Code for Information Interchange oder ASCII ist eine Zeichencodierung, die 1963 definiert wurde. Sie umfasst 95 normale Zeichen und 33 Steuerzeichen. 

Steuerzeichen sind spezielle Zeichen, welche beispielsweise einen Zeilen- oder Seitenumbruch darstellen.

ASCII ist ein sehr weit verbreiteter Standard, um Text zu codieren. Er war ursprünglich für eine Codierung mit 7 Bit pro Zeichen ausgelegt. Heute verwenden wir pro ASCII-Zeichen aber meist 8 Bit (also 1 Byte), weil moderne Computer meistens nur mit ganzen Bytes als kleinstmögliche Dateneinheit arbeiten.

Die normalen ASCII-Zeichen sind in der folgenden Tabelle aufgeführt:

<details>
<summary>ASCII-Tabelle</summary>
:::cards
| Zeichen | Binär | Hex |
|--------|--------|-----|
| ␣ | 00100000 | 20 |
| ! | 00100001 | 21 |
| " | 00100010 | 22 |
| # | 00100011 | 23 |
| $ | 00100100 | 24 |
| % | 00100101 | 25 |
| & | 00100110 | 26 |
| ' | 00100111 | 27 |
| ( | 00101000 | 28 |
| ) | 00101001 | 29 |
| * | 00101010 | 2A |
| + | 00101011 | 2B |
| , | 00101100 | 2C |
| - | 00101101 | 2D |
| . | 00101110 | 2E |
| / | 00101111 | 2F |
| 0 | 00110000 | 30 |
| 1 | 00110001 | 31 |
| 2 | 00110010 | 32 |
| 3 | 00110011 | 33 |
| 4 | 00110100 | 34 |
| 5 | 00110101 | 35 |
| 6 | 00110110 | 36 |
| 7 | 00110111 | 37 |
| 8 | 00111000 | 38 |
| 9 | 00111001 | 39 |
| : | 00111010 | 3A |
| ; | 00111011 | 3B |
| \< | 00111100 | 3C |
| = | 00111101 | 3D |
| > | 00111110 | 3E |
| ? | 00111111 | 3F |
::br
| Zeichen | Binär | Hex |
|--------|--------|-----|
| @ | 01000000 | 40 |
| A | 01000001 | 41 |
| B | 01000010 | 42 |
| C | 01000011 | 43 |
| D | 01000100 | 44 |
| E | 01000101 | 45 |
| F | 01000110 | 46 |
| G | 01000111 | 47 |
| H | 01001000 | 48 |
| I | 01001001 | 49 |
| J | 01001010 | 4A |
| K | 01001011 | 4B |
| L | 01001100 | 4C |
| M | 01001101 | 4D |
| N | 01001110 | 4E |
| O | 01001111 | 4F |
| P | 01010000 | 50 |
| Q | 01010001 | 51 |
| R | 01010010 | 52 |
| S | 01010011 | 53 |
| T | 01010100 | 54 |
| U | 01010101 | 55 |
| V | 01010110 | 56 |
| W | 01010111 | 57 |
| X | 01011000 | 58 |
| Y | 01011001 | 59 |
| Z | 01011010 | 5A |
| [ | 01011011 | 5B |
| \ | 01011100 | 5C |
| ] | 01011101 | 5D |
| ^ | 01011110 | 5E |
| _ | 01011111 | 5F |
::br
| Zeichen | Binär | Hex |
|--------|--------|-----|
| ` | 01100000 | 60 |
| a | 01100001 | 61 |
| b | 01100010 | 62 |
| c | 01100011 | 63 |
| d | 01100100 | 64 |
| e | 01100101 | 65 |
| f | 01100110 | 66 |
| g | 01100111 | 67 |
| h | 01101000 | 68 |
| i | 01101001 | 69 |
| j | 01101010 | 6A |
| k | 01101011 | 6B |
| l | 01101100 | 6C |
| m | 01101101 | 6D |
| n | 01101110 | 6E |
| o | 01101111 | 6F |
| p | 01110000 | 70 |
| q | 01110001 | 71 |
| r | 01110010 | 72 |
| s | 01110011 | 73 |
| t | 01110100 | 74 |
| u | 01110101 | 75 |
| v | 01110110 | 76 |
| w | 01110111 | 77 |
| x | 01111000 | 78 |
| y | 01111001 | 79 |
| z | 01111010 | 7A |
| \{ | 01111011 | 7B |
| \| | 01111100 | 7C |
| \} | 01111101 | 7D |
| ~ | 01111110 | 7E |
:::
</details>

:::insight[Steuerzeichen]
Die ASCII-Codierung kennt noch 33 weitere Zeichen, welche zum Beispiel zur Steuerung von Druckern gebraucht werden. Man nennt sie deshalb Steuerzeichen. Darin enthalten sind Zeichen wie `LF` (Hex: $A$) für einen Zeilenumbruch und `DEL` (Hex: $7F$) um ein Zeichen zu löschen. Der Übersicht halber sind diese Zeichen in der obigen Tabelle nicht aufgeführt.
:::

## Konstante Zeichenlänge
Oben haben Sie gelernt, dass z.B. das Zeichen `&` dem ASCII-Wert $00100110_2$ entspricht. Diese Zahl beginnt aber mit zwei Nullen. Bei einer Dezimalzahl würden Sie normalerweise nicht $0023_{10}$ schreiben, sondern $23_{10}$, richtig?

Wäre es dann also nicht einfacher, wenn wir das Zeichen `&` als $100110_2$ codieren würden? Man würde damit ja auch Platz sparen, da jede Ziffer 1 Bit Speicher benötigt.

Das stimmt zwar, aber wir hätten damit auch ein Problem. Wir müssen eine Bitfolge auch wieder decodieren können, und dazu müssen wir wissen, wo ein Zeichen endet und wo das nächste beginnt. Wie würden Sie jetzt zum Beispiel bei der Bitfolge `10010101100001100001` herausfinden, welche ASCII-Zeichen hier drin stecken? Eine mögliche Aufteilung wäre `10010|101|100001|100001`, eine andere Aufteilung wäre `1001010|1100001|100001`. Welche ist nun gemeint? Wir können diese Bitfolge **nicht eindeutig decodieren**.

:::key[Keine Leerschläge]
Denken Sie daran: **Der Computer kennt in einer Bitfolge keine "Leerschläge".**  Er unterscheidet nur zwischen "Strom" (also $1$) und "kein Strom" (also $0$).
:::

Deshalb verlassen wir uns bei der ASCII-Codierung darauf, dass wir für jedes Zeichen **immer genau 8 Bits** verwenden. So können Sie beispielsweise die Bitfolge `010010100110000100100001` in einfach Achter-Pakete aufteilen und erhalten `01001010|01100001|00100001`. Wenn Sie dann die drei Werte `01001010`, `01100001` und `00100001` in der ASCII-Tabelle nachschlagen, sehen Sie, dass hier der String `Ja!` codiert wurde. Mit dieser Regel lässt sich jede ASCII-codierte Bitfolge also **eindeutig decodieren**.

## Aufgaben
:::aufgabe[Kurzaufagben]
<TaskState id="8760b2d3-66f5-487a-be90-e6552eb80b28" />

Beantworten Sie die folgenden Fragen und prüfen Sie jeweils Ihre Eingabe.

| Frage | Antwort |
| - | - |
| Wieviele Zeichen lassen sich mit 7 Bit maximal codieren? | <String id="c252d6b1-6315-4040-a19d-07a73354a9fb" solution="128" placeholder="Zahl eingeben" /> |
| Welches ist der Code für das Zeichen `A`? Geben sie den Code als binäre und als dezimale Zahl an. | <String id="ff714c34-347c-44fe-b3f0-54b773c65194" solution="01000001" label="Binärzahl" placeholder="Zahl eingeben" /><br/><String id="a379fd03-2246-4129-afb1-6c8a865bccce" solution="65" label="Hex-Zahl" placeholder="Zahl eingeben" /> |
| Für welches Zeichen steht der Code `01100001`? | <String id="62537e03-46d9-4469-82fe-2215c0de9849" solution="a" placeholder="Zeichen eigeben" /> |
| Für welches Zeichen steht der Code `00110000`? | <String id="fc46516e-0e28-483a-9e11-920fff20f667" solution="0" placeholder="Zeichen eigeben" /> |
:::

:::key[Zahlen und Ziffern]
Ziffern (`0`, `1`, etc.) können auch als Zeichen dargestellt werden. Der Code `00110001` steht in ASCII-Code für das Zeichen `1`.

Wir müssen uns also immer bewusst sein, ob wir jetzt über die Zahl $1$ (als binäre Zahl mit acht Stellen `00000001`) oder das Zeichen `1` sprechen.

Damit es kein Durcheinander gibt, werden in den meisten Programmiersprachen die Anführungszeichen verwendet, wenn die Ziffern als Zeichen – sprich, als normaler Text – interpretiert werden sollen:

```py
x = 1
y = "1"
```

Im obigen Python-Beispiel sieht das also folgendermassen aus:

`x`
: ist ein Integer und entspricht somit der Zahl `00000001`.
`y`
: ist ein String und entspricht dem ASCII-Zeichen mit dem Code `00110001`.
:::

:::aufgabe[Text-Binär-Codierer]
<TaskState id="0d8ca6f9-843a-4ea8-b46b-e389bf3fc9dd" />
Auf [dieser Seite](https://magictool.ai/tool/binary-to-text/de/) können Sie einerseits normalen Text in die binäre Darstellung umwandeln (codieren) und andererseits binäre Codes zu normalem Text decodieren.

***

**Teil A:**
1. Erstellen Sie zuerst mithilfe der ASCII-Tabelle (siehe oben) die binäre Darstellung den Text `Das kostet 1 Fr.`.
2. Gehen Sie zum Konverter (verlinkte Seite) und stellen Sie sicher, dass dort __BINÄR ZU TEXT__ ausgewählt ist.
3. Geben Sie die entstandene Bitfolge dort in das Feld __Binärcode__ ein. Sie dürfen dabei nur die Ziffern 0 und 1 verwenden, also keine Leerschläge und Hochkommas.
4. Drücken Sie __Konvertieren__.

Wenn Ihr Code stimmt, dann sehen Sie jetzt im untersten Feld den ursprünglichen Text. Hat's geklappt? Korrigieren Sie Ihren Binärcode, falls nötig.

Halten Sie den fertigen Binärcode hier fest:

<QuillV2 id="a2927eee-1bab-495a-a552-5fe41f2eeab1" />

***

**Teil B:**\
Bearbeiten Sie Ihren Binärcode wie folgt:
1. Fügen Sie nach den ersten 8 Bits (also nach der Binärdarstellung des Buchstabens `D`) den Code `00001010` ein.
2. Drücken Sie anschliessend nochmal auf __Konvertieren__.

Was bewirkt dieser Code? Geben Sie Ihre Antwort als Text ein und überprüfen Sie ihre Lösung.

<Solution id="ff279193-bdc8-4aa8-84d3-37b91626ca5a">
**Teil A:**\
`01000100011000010111001100100000011010110110111101110011011101000110010101110100001000000011000100100000010001100111001000101110`
<br/>
**Teil B:**\
Es handelt sich um das Steuerzeichen `LF`, welches einen Zeilenwechsel bewirkt.
</Solution>
:::

---